!to "rope-sine.prg", cbm
*=$0801

; BASIC stub: 10 SYS 2064
!byte $0c,$08,$0a,$00,$9e,$20,$32,$30,$36,$34,$00,$00,$00

jmp main

*=$2000

main

; Clear screen
  lda #$20
  ldx #0
clrloop
  sta $0400, x
  sta $0500, x
  sta $0600, x
  sta $0700, x
  dex
  bne clrloop

; Set all color RAM to white
  lda #$01
  ldx #0
colrloop
  sta $d800, x
  sta $d900, x
  sta $da00, x
  sta $db00, x
  dex
  bne colrloop

; Set screen colors
  lda #$00  ; black background
  sta $d021
  lda #$00  ; black border
  sta $d020

; Setup interrupt / timer
  sei

; Disable signals from CIA-1 (maskable IRQ)
  lda #%01111111
  sta $dc0d

; Clear VIC raster register bit 8
  lda $d011
  and #%01111111
  sta $d011

; Ack pending irqs CIA-1 and CIA-2
  lda #%01111111
  sta $dc0d
  sta $dd0d

; Set interrupt on raster line 50
  lda #50
  sta $d012

; Set interrupt address
  lda #<irq
  ldx #>irq
  sta $0314
  stx $0315

; Enable raster irq mode from VIC
  lda #%00000001
  sta $d01a

; Initialize animation frame counter
  lda #0
  sta frame_counter

  cli

endless
  jmp endless

; IRQ handler - draws 24 vertical ropes in sine wave pattern
irq
  ; Clear entire screen first (simple but effective)
  lda #$20
  ldx #0
  ldy #0
clr_screen
  sta $0400,x
  sta $0500,x
  sta $0600,x
  sta $0700,x
  inx
  bne clr_screen

  ; Draw 24 ropes
  ldy frame_counter  ; Current animation frame
  ldx #0             ; Rope counter
  
draw_ropes
  ; Calculate index into sine data: frame_counter * 24 + rope_number
  ; For simplicity, we'll use modulo addressing
  
  ; Get base offset for current frame (y * 24)
  ; We'll use a lookup approach for this frame
  tya
  and #$FF  ; Ensure it wraps at 256
  sta temp_frame
  
  ; Calculate offset: temp_frame * 24 + x
  lda temp_frame
  asl  ; *2
  sta temp_a
  asl  ; *4
  asl  ; *8
  adc temp_a  ; *10
  adc temp_a  ; *12
  asl  ; *24
  sta temp_offset
  
  txa
  clc
  adc temp_offset
  tay
  
  ; Get Y position from sine data
  lda sine_data,y
  
  ; Convert pixel Y (50-230) to screen row (0-24)
  sec
  sbc #50  ; Remove offset
  lsr      ; /2
  lsr      ; /4
  lsr      ; /8 (roughly)
  cmp #25
  bcc y_ok
  lda #24
y_ok
  ; Y position in accumulator (0-24)
  tay
  
  ; Get screen address for this row
  lda screen_rows_lo,y
  sta rope_ptr
  lda screen_rows_hi,y
  sta rope_ptr+1
  
  ; Get X position for this rope
  lda rope_x_pos,x
  tay
  
  ; Draw vertical line character
  lda #$a0  ; Block character
  sta (rope_ptr),y
  
  ; Next rope
  ldy frame_counter
  inx
  cpx #24
  bne draw_ropes

  ; Advance animation
  inc frame_counter

; Ack interrupt / clear VIC interrupt flag
  asl $d019

; Finish interrupt
  jmp $ea81

; Variables
frame_counter = $02
temp_frame = $03
temp_a = $04
temp_offset = $05
rope_ptr = $FB  ; Zero page pointer for indirect addressing

; X positions for 24 ropes (columns)
rope_x_pos
  !byte 1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35

; Screen row start addresses (low bytes) - 25 rows
screen_rows_lo
  !byte <$0400,<$0428,<$0450,<$0478,<$04a0,<$04c8,<$04f0,<$0518
  !byte <$0540,<$0568,<$0590,<$05b8,<$05e0,<$0608,<$0630,<$0658
  !byte <$0680,<$06a8,<$06d0,<$06f8,<$0720,<$0748,<$0770,<$0798,<$07c0

; Screen row start addresses (high bytes) - 25 rows
screen_rows_hi
  !byte >$0400,>$0428,>$0450,>$0478,>$04a0,>$04c8,>$04f0,>$0518
  !byte >$0540,>$0568,>$0590,>$05b8,>$05e0,>$0608,>$0630,>$0658
  !byte >$0680,>$06a8,>$06d0,>$06f8,>$0720,>$0748,>$0770,>$0798,>$07c0

; Include sine wave data generated by Python script
sine_data
!src "rope-sine-data.i"
